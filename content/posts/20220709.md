+++ 
draft = true
date = 2022-07-09T14:22:27+09:00
title = "도메인 주도 설계로 시작하는 마이크로서비스 개발[1]"
slug = ""
authors = []
tags = ["MSA", "독서"]
categories = []
externalLink = ""
series = []
+++

# SOA와 마이크로 서비스

- 소프트웨어 공학의 모듈화 개념의 발전 과정
    - 기능을 하향식 분해해서 설계해 나가는 구조적(structured) 방법론.
    - 객체 단위로 모듈화 하기 위한 객체지향(object-oriented) 방법론.
    - 모듈화의 단위가 기능별로 재사용할 수 있는 좀 더 큰 컴포넌트가 되는 CBD(Component Based Development)
    - 컴포넌트를 모아 비즈니스적으로 의미 있고 완결적인 서비스 단위로 모듈화 하는 SOA(Service Oriented Architecture)
    - 마이크로 서비스를 기반으로 시스템을 개발하는 MSA (Micro Service Architecture)
- MSA와 SOA의 결정적인 차이점
    - MSA는 서비스별 저장소를 분리해서 다른 서비스에서 저장소를 직접 호출하지 못하도록 캡슐화 한다. 즉, 다른 서비스의 저장소에 접근하는 방법은 API 밖에 없다.
    - MSA는 REST API 같은 가벼운 개방형 표준을 사용해 각 서비스가 느슨하게 연계되고 누구나 쉽게 사용할 수 있다.

# 클라우드 서비스 유형 별 대표 서비스

- IaaS (Infrastructure as a Service)
    - 가상 머신, 스토리지, 네트워크 같은 인프라를 필요한 만큼 적시에 제공하는 서비스로서 사용자는 이러한 인프라를 이용해 개발환경을 구축한 다음, 애플리케이션을 배포한다. (가상 서버, 가상 네트워크, 가상 스토리지)
    - 대표 서비스 : AWS EC2, GCP Comupte Engine, Azure VM
- CaaS (Container as a Service)
    - 컨테이너 기반 가상화를 사용해 컨테이너를 업로드, 구성, 실행, 확장, 중지할 수 있는 서비스. 애플리케이션을 바로 실행할 수 있는 환경을 제공한다는 점에서 PaaS와 유사하지만, 다른 환경에도 이식 가능한 컨테이너 기반 가상화를 제공한다는 점이 다르다.
    - 대표 서비스 : Azure Kubernetes Service (AKS), 아마존 Elastic Kubernetes, 구글 Kubernetes Engine, AWS ECS
- PaaS (Platform as a Service)
    - 복잡함 없이 애플리케이션을 곧바로 개발, 실행, 관리할 수 있는 플랫폼 환경을 서비스 형태로 제공한다. IaaS 위에 실제로 애플리케이션이 실행될 수 있는 미들웨어나 런타임까지 탑재된 환경이라 생각하면 이해하기 쉽다.
    - 대표 서비스 : Azure Web App, Google App Engine, Cloud Foundry, AWS Elastic Beanstalk

# 데브옵스 인프라 구성

> 서비스를 빌드하고 테스트한 뒤, 배포할 수 있게 도와주는 개발 지원 환경 (DevOps)
> 
- CI/CD (자동화된 빌드나 배포 작업)
    - CI : 지속적 통합 (Continuous Integration)
        - 자동으로 통합 및 테스트하고 그 결과를 리포트로 기록하는 활동
    - CD : 지속적 제공 (Continuous Delivery) 및 지속적 배포 (Continuous Deployment)
        - 소스코드 저장소에서 빌드한 소스코드의 실행 파일을 실행 환경까지 자동으로 배포하는 방식.
- CI/CD 파이프라인의 설계
    
    > CI/CD 파이프라인이란 ? 빌드/배포되는 과정 동안 수행해야 할 태스크가 정의된 것
    > 
    - 레포지토리 → 빌드 & 유닛테스트 → 정적 분석 → 통합 테스트 → 배포
    - CI/CD 단계의 자동화 요소들
        - 레포지토리에서 소스코드를 가져와 빌드해서 실행 파일을 만드는 작업.
        - 실행 파일을 실행 환경에 배포하는 작업.
        - 앞의 작업들을 통제하고 연결해서 전 작업이 성공하면 다음 작업이 자동으로 수행되게 하는 연계 자동화 작업.

# 마이크로서비스의 어플리케이션 아키텍처

> 유연하고 확장성 있는 MSA 시스템을 만들기 위해서는 각 마이크로서비스의 관계를 유연하게 만드는 MSA 외부 아키텍처 및 패턴도 중요하지만 마이크로서비스 내부 구조를 어떻게 유연하게 만들것인지도 중요하다.
> 
- DB 중심 아키텍처의 문제점
    - DB 중심 아키텍처란, 특정 관계형 데이터베이스에 의존한 데잉터 모델링을 수행한 다음 이 물리 테이블 모델을 중심에 두고 애플리케이션을 구현하기 위한 사고를 하는 방식.
- 어플리케이션의 성능은 곧 DB의 처리 성능과 같으며, DB의 데이터가 늘어나면 늘어날 수록, 성능은 떨어질 수 밖에 없는 구조이다. (이는, 클라우드 인프라를 통한 자동 스케일 아웃이 의미가 없게 된다.)
- 클라우드의 풍부한 자원 환경에서는 애플리케이션 자체의 성능 보다는 애플리케이션의 확장성과 유연함이 더 중요하다. 따라서 앞에서 언급한 관심사의 분리 원칙에 따라 끈끈하게 결합돼있던 **비즈니스 로직 처리와 데이터 처리를 철저히 분리**하는 것이 반드시 필요하다.

## 헥사고날 아키텍처와 클린 아키텍처

### 레이어드 아키텍처

- 레이어드 아키텍처의 ‘레이어’란,
    - 물리적인 ‘티어’의 개념과 달리, 논리적인 개념이다. ‘티어'는 장비나 서버 컴퓨터 등의 물리층을 의미하고. 레이어는 티어 내부의 논리적인 분할을 의미한다.
- 서버'티어'를 구성하는 3가지 레이어 (논리적인 계층)
    - 프레젠테이션 : 화면 표현 및 전환 처리
    - 비즈니스 로직 : 비즈니스 개념, 규칙, 흐름 제어
    - 데이터 액세스 : 데이터 처리
- 레이어드 아키텍처의 규칙
    - 상위 계층이 하위 계층을 호출하는 **단방향성**을 유지한다.
    - 상위 계층은 하위의 여러 계층을 모두 알 필요 없이, **바로 밑의 근접 계층만 활용**한다.
    - 상위 계층이 **하위 계층에 영향을 받지 않게 구성**해야 한다.
    - 하위 계층은 **자신을 사용하는 상위 계층을 알지 못하게 구성**해야 한다.
    - 계층간의 호출은 **인터페이스를 통해 호출하는 것**이 바람직하다.
- 한계점
    - 인터페이스를 통한 DIP를 만족하는 것 처럼 보이지만, OCP(개방 폐쇄 원칙 : 개체는 행위의 확장에는 열려 있어야 하고, 개체의 변경에는 닫혀있어야 한다.)에 위배된다
    - 일반적인 레이어드 아키텍처의 인터페이스는 모든 계층이 각기 자신이 제공하는 기능에 대한 추상적인 인터페이스를 직접 정의하고 소유하고 있는 구조이기 때문. (이런 구조에서는 제어 흐름이 상위 계층에서 하위 계층으로 흐르게 되고, 이에 따른 소스코드의 의존성은 제어 흐름의 방향대로 따를 수 밖에 없다.)
    - 현대 애플리케이션에서는 프레젠테이션 계층과 데이터 액세스 계층 말고도 다양한 인터페이스를 필요로 한다. 즉, 애플리케이션을 호출하는 다양한 시스템의 유형과 애플리케이션과 상호작용하는 다양한 저장소가 존재한다. 레이어드 아키텍처는 이런 점을 지원하기 힘들다.

### 헥사고날 아키텍처

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e0234bcd-30e0-40ba-8a5a-507e73477172/Untitled.png)

- 앨리스테어 콕번이 제시한 아키텍처로, ‘포트 앤 어댑터 아키텍처'라고도 한다.
    - 고수준의 비즈니스 로직을 표현하는 ‘**내부 영역**’
        - 내부 영역은 순수한 비즈니스 로직을 표현하는 기술 독립적인 영역.
        - 외부 영역과는 ‘**포트**’를 통해 소통한다.
    - 인터페이스 처리를 담당하는 저수준의 ‘**외부 영역**’의 구성
        - 외부 영역은 외부에서 들어오는 요청을 처리하는 ‘**인바운드 어댑터**‘
        - 비즈니스 로직에 의해 호출되어 외부와 연계되는 ‘**아웃바운드 어댑터’**
        - 외부 영역의 어댑터에는 인바운드 어댑터로는 REST API를 발행하는 컨트롤러, 웹페이지를 구성하는 스프링 MVC 컨트롤러, 커맨드 핸들러, 이벤트 메시지 구독 핸들러 등이 될 수 있고, 아웃바운드 어댑터로는 데이터 액세스 처리를 담당하는 DAO, 이벤트 메시지를 발행하는 클래스, 외부 서비스를 호출하는 프락시 등이 있다.
- 헥사고날 아키텍처의 가장 큰 특징은 고수준의 내부 영역이 **구체 어댑터에 전혀 의존하지 않게** 한다는 것.

### 클린 아키텍처

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/039e7694-4606-4be0-bd75-2691ce79b152/Untitled.png)

- 로버트 C.마틴이 제안한 아키텍처로서 헥사고날 아키텍처의 아이디어와 매우 유사하다.
- 중앙에는 ‘**엔티티**'가 있다.
    - ‘**업무 규칙**’이란, 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차로, 수동 처리할 수 있지만 시스템으로도 자동화할 수 있다. 예를 들면, 쇼핑몰의 물건을 사고 파는 규칙, 은행의 이자 계산 규칙, 도서대출 시스템의 대출/반납 규칙 등 모든 시스템에는 해당 **도메인의 업무를 규정하는 핵심 업무 규칙**이 존재한다. 그리고 **핵심 업무 규칙은 보통 데이터를 요구**한다. → 핵심 규칙과 데이터는 본질적으로 결합돼 있기 때문에 객체로 쉽게 만들 수 있다. 이런 유형을 ‘**엔티티**’ 라고 한다.
    - 엔티티 같은 **고수준의** 영역은 저수준의 유스케이스 영역을 알게 해서는 안 된다.
    - 엔티티는 간단한 객체여야 하며, 프레임워크 데이터베이스 또는 기타 복잡한 것에 의존해서는 안 되고 아래 **유스케이스 객체**를 통해서만 조작해야 한다.
- 엔티티를 감싸고 있는 ‘**유스케이스’**
    - 유스케이스는 **자동화된 시스템을 사용하는 처리 절차**를 기술한다.
    - 엔티티 내부의 핵심 업무 규칙을 호출하며 시스템을 사용하는 흐름을 담는다
- 유스케이스를 감싸고 있는 ‘**세부사항**’
    - 세부사항으로는 입출력 장치, 저장소, 웹 시스템, 서버, 프레임워크, 통신 프로토콜이 될 수 있으며, 세부사항과 유스케이스의 관계를 의존 관계 역전의 원칙을 이용해 플러그인처럼 유연하게 처리해야 한다.
- **이런 명확한 결합의 분리는 테스트 용이성 및 개발 독립성, 배포 독립성을 보장할 수 있다.**
