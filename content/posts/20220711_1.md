+++ 
draft = true
date = 2022-07-11T09:03:50+09:00
title = "객체지향 개발 5대 원칙 (SOLID 원칙)"
description = ""
slug = ""
authors = []
tags = ["객체지향","OOP"]
categories = ["TIL"]
externalLink = ""
series = []
+++
## SRP - 단일 책임의 원칙 (Single Responsibility Principle)

> *작성된 클래스는 하나의 기능만 가지며, 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는 데 집중되어 있어야 한다. (어떤 변화에 의헤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다)*
> 
- 장점
    - 책임 영역이 확실해져 책임 변경 위험에서 자유롭다.
    - 책임을 적절히 분배함으로써 코드의 가독성이 향상되고, 유지보수에 용이하다.
- 적용 방법
    - 여러 원인에 의한 변경 (Divergent change) : Extract class를 통해 혼재된 각 책임을 각각의 클래스로 분할하여 클래스 당 하나의 책임만을 맡도록 하는 것. 만약 Extract class된 각각의 클래스들이 유사하고 비슷한 책임을 중복해서 갖고 있는 경우, Extract Superclass를 사용한다. (공유되는 요소를 부모 클래스로 정의하여 부모클래스에 위임하는 기법) 따라서 각각의 Extract class들의 유사한 책임들은 부모 클래스가 담당하게 되고, 각기 다른 책임은 개별 Extract class에 정의할 수 있다.
    - 산탄총 수술(Shotgun surgery) : Move Field와 Move Method를 통해 책임을 기존의 어떤 클래스로 모으거나, 이럴만한 클래스가 없다면 새로운 클래스를 만들어 해결하는 방식. (산발적으로 여러 곳에 분포된 책임들을 한 곳에 모으면서 설계를 깨끗하게 한다. → **응집도를 높인다.**)
- 제약 사항
    - 클래스는 자신의 이름이 나타내는 일을 해야한다. 올바른 클래스 이름을 지어야한다.
    - 각 클래스는 하나의 개념을 나타내어야 한다.
    - 사용되지 않는 속성이 결정적 증거다.

## OCP - 개방 폐쇄의 원칙 (Open Close Principle)

> *버틀란트 메이어 박사가 1998년 객체지향 소프트웨어 설계 라는 책에서 정의한 내용으로, 소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고 변경에는 닫혀있어야 한다는 원리. (요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다)*
> 
- 장점
    - 재사용 가능한 코드를 만드는 기반이 되는 원칙. (객체지향의 장점을 극대화 하는 원리)
- 적용 방법
    - 변경(확장)될 것과 변하지 않을 것을 엄격하게 구분한다.
    - 이 두 모듈이 만나는 지점에 인터페이스를 정의한다.
    - 구현에 의존하기보다는 정의한 인터페이스에 의존하도록 코드를 작성한다.
- 제약 사항
    - 확장되는 것과 변경되지 않는 모듈을 분리하는 과정에서 크기 조절에 실패하면 오히려 관계가 복잡해질 수 있다.
    - 인터페이스는 가능하면 변경되어서는 안 된다. 따라서 인터페이스를 정의할 때, 여러 경우의 수에 대한 고려와 예측이 필요하다.
    - 인터페이스 설계에서 적당한 추상화 레벨을 선택해야 한다.

## LSP - 리스코브 치환의 원칙 (The Liskov Substitution Principle)

> *서브타입은 언제나 기반 타입으로 교체할 수 있어야 한다는 원칙. 서브 클래스가 확장에 대한 인터페이스를 준수해야 함. 다형성과 확장성을 극대화 하기 위해서는 하위 클래스를 사용하기 보다는 상위의 클래스(인터페이스)를 사용하는 것이 더 좋다. 상속을 통한 재사용은 기반 클래스와 서브 클래스 사이에 IS - A 관계까 있을 경우로만 제한되어야 하며, 그 외의 경우에는 합성을 이용한 재사용을 해야한다. (대표적인 예 : 자바 컬렉션 프레임워크)*
> 
- 적용 방법
    - 만약 두 개체가  똑 같은 일을 한다면 둘을 하나의 클래스로 표현하고 이들을 구분할 수 있는 필드를 둔다.
    - 똑같은 연산을 제공하지만, 이들을 약간씩 다르게 한다면 공통의 인터페이스를 만들고 둘이 이를 구현 한다. (인터페이스 상속)
    - 공통된 연산이 없다면 완전 별개인 2개의 클래스를 만든다.
    - 만약 두 개체가 하는 일에 추가적으로 무언가를 더 한다면 구현 상속을 사용한다.
- 제약사항
    - 상속 구조가 필요 하다면 Extract Subclass, Push Down Field, Push Down Method 등의 리팩토링 기법을 이용하여 LSP를 준수하는 상속 계층 구조를 구성한다.
    - Design by Contract 적용 : 기반 클래스를 서브 클래스로 치환 가능하게 하려면 받아들이는 선 조건에서 서브클래스의 제약사항이 기반 클래스의 제약 사항보다 누슨하거나 같아야 한다. (만약 제약조건이 더 강하다면 기반 클래스에서는 실행되는 사항이 서브 클래스에서 실행되지 않을 수 있기 때문, 반면 서브 클래스의 후 조건은 같거나 더 강해야 하는데, 약하다면 기반 클래스의 후 조건이 통과시키지 않는 상태를 통과시킬 수 있기 때문.)

## ISP - 인터페이스 분리 원칙 (Interface Segregation Principle)

> *한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리. 즉, 어떤 클래스가 다른 클래스에 종속될 때에는 가능한 최소한의 인터페이스만 사용해야 한다. 만약 어떤 클래스를 이용하는 클라이언트가 여러 개고 이들이 해당 클래스의 특정 부분집합만을 이용한다면, 이들을 따로 인터페이스로 빼내어 클라이언트가 기대하는 메세지만을 전달할 수 있도록 해야한다.*
> 
- 적용 방법
    - 클래스 인터페이스를 통한 분리 : 클래스의 상속을 이용하여 인터페이스를 나눌 수 있다. 이와 같은 구조는 클라이언트에게 변화를 주지 않을 뿐 아니라, 인터페이스를 분리하는 효과를 갖는다. 하지만 거의 모든 객체지향 언어에서는 상속을 이용한 확장은 상속받는 클래스의 성격을 디자인 시점에 규정해버린다.
    - 객체 인터페이스를 통한 분리 : 위임 (Delegation)을 이용하여 인터페이스를 나눌 수 있다.
- 제약 사항
    - 기 구현된 클라이언트에 변경 요소를 주지 않아야 한다.
    - 두 개 이상의 인터페이스가 공유하는 부분의 재사용을 극대화 한다.
    - 서로 다른 성격의 인터페이스를 명백히 분리한다.

## DIP - 의존성 역전의 원칙 (Dependency Inversion Principle)

> *고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다. 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.*
> 
- 적용 방법
    - Layering(레이어링) : 잘 구조화 된 객체지향 아키텍처들은 각 레이어마다 잘 정의되고 통제되는 인터페이스를 통한 긴밀한 서비스들의 집합을 제공하는 레이어들로 구성되어 있다. 이는 상위 레벨의 레이어가 하위 레벨의 레이어를 바로 의존하게 하는 것이 아니라, 이 둘 사이에 존재하는 추상레벨을 통해 의존해야 할 것을 말한다. 이를 통해 상위레벨의 모듈은 하위 레벨의 모듈로의 의존성에서 벗어나 그 자체로 재사용 되고 보장 받을 수 있다.
